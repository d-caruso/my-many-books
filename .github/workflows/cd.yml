name: Monorepo CD

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      projects:
        description: 'Projects to deploy (comma-separated: api,web-app)'
        required: true
        default: 'api'
        type: string

env:
  NODE_VERSION: '20.x'
  AWS_REGION: 'us-east-1'

jobs:
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy: ${{ steps.env.outputs.should-deploy }}
      affected-projects: ${{ steps.affected.outputs.projects }}
      deploy-api: ${{ steps.projects.outputs.deploy-api }}
      deploy-web-app: ${{ steps.projects.outputs.deploy-web-app }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          check-latest: true

      - name: Install Dependencies
        run: |
          # Generate lockfile with correct Node version if needed
          if ! npm ci 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install
          fi

      - name: Determine Environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine Affected Projects
        id: affected
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PROJECTS="${{ github.event.inputs.projects }}"
          else
            # Get the list of affected projects and filter out "my-many-books" using grep.
            # This is a more robust method than using sed.
            PROJECTS=$(npx nx show projects --affected --base=origin/main~1 --head=HEAD | grep -v 'my-many-books' | tr '\n' ',' | sed 's/,$//')
          fi
          echo "projects=$PROJECTS" >> $GITHUB_OUTPUT
          echo "Affected projects: $PROJECTS"

      - name: Determine Projects to Deploy
        id: projects
        run: |
          PROJECTS="${{ steps.affected.outputs.projects }}"
          
          if [[ "$PROJECTS" == *"api"* ]]; then
            echo "deploy-api=true" >> $GITHUB_OUTPUT
          else
            echo "deploy-api=false" >> $GITHUB_OUTPUT
          fi
          
          if [[ "$PROJECTS" == *"web-app"* ]]; then
            echo "deploy-web-app=true" >> $GITHUB_OUTPUT
          else
            echo "deploy-web-app=false" >> $GITHUB_OUTPUT
          fi

  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    needs: [setup]
    if: needs.setup.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          check-latest: true

      - name: Install Dependencies
        run: |
          # Use lockfile if compatible, otherwise regenerate
          if ! npm ci 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install --legacy-peer-deps
          fi

      - name: Build Projects to be Deployed
        # This step has been updated to build projects by changing the working directory
        # to prevent failures caused by Nx or npm workspace analysis.
        run: |
          BUILD_PROJECTS="${{ needs.setup.outputs.affected-projects }}"
          if [ -n "$BUILD_PROJECTS" ]; then
            IFS=',' read -ra ADDR <<< "$BUILD_PROJECTS"
            for project in "${ADDR[@]}"; do
              if [ "$project" == "api" ]; then
                echo "Building project: $project"
                cd apps/api && npm run build
              elif [ "$project" == "web-app" ]; then
                echo "Building project: $project"
                cd apps/web-app && npm run build
              else
                echo "Skipping non-deployable project: $project"
              fi
            done
          else
            echo "No projects to build for deployment."
          fi

      - name: Run Security Checks
        run: |
          npm audit --audit-level=high
          npx audit-ci --high
        continue-on-error: true

      - name: Validate Environment Configuration
        run: |
          echo "Validating configuration for ${{ needs.setup.outputs.environment }} environment"

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [setup, pre-deployment-checks]
    environment: ${{ needs.setup.outputs.environment }}
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.deploy-api == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Infrastructure Stack
        run: |
          STACK_NAME="my-many-books-infrastructure-${{ needs.setup.outputs.environment }}"
          TEMPLATE_FILE="apps/api/deployment/cloudformation/infrastructure.yml"
          
          # Set parameters based on environment
          PARAMETERS="ParameterKey=Environment,ParameterValue=${{ needs.setup.outputs.environment }}"
          
          case "${{ needs.setup.outputs.environment }}" in
            "prod")
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseInstanceClass,ParameterValue=db.t3.small"
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseAllocatedStorage,ParameterValue=50"
              PARAMETERS="$PARAMETERS ParameterKey=EnableMultiAZ,ParameterValue=true"
              ;;
            "staging")
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseInstanceClass,ParameterValue=db.t3.micro"
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseAllocatedStorage,ParameterValue=20"
              PARAMETERS="$PARAMETERS ParameterKey=EnableMultiAZ,ParameterValue=false"
              ;;
            "dev")
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseInstanceClass,ParameterValue=db.t3.micro"
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseAllocatedStorage,ParameterValue=20"
              PARAMETERS="$PARAMETERS ParameterKey=EnableMultiAZ,ParameterValue=false"
              ;;
          esac
          
          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name "$STACK_NAME" >/dev/null 2>&1; then
            echo "Updating existing infrastructure stack: $STACK_NAME"
            aws cloudformation update-stack \
              --stack-name "$STACK_NAME" \
              --template-body "file://$TEMPLATE_FILE" \
              --parameters $PARAMETERS \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM || {
                exit_code=$?
                if [ $exit_code -eq 255 ]; then
                  echo "No updates to perform for infrastructure stack"
                else
                  echo "Failed to update infrastructure stack"
                  exit $exit_code
                fi
              }
            
            echo "Waiting for stack update to complete..."
            aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"
          else
            echo "Creating new infrastructure stack: $STACK_NAME"
            aws cloudformation create-stack \
              --stack-name "$STACK_NAME" \
              --template-body "file://$TEMPLATE_FILE" \
              --parameters $PARAMETERS \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
            
            echo "Waiting for stack creation to complete..."
            aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME"
          fi
          
          echo "Infrastructure deployment completed successfully"

      - name: Run Database Migrations
        working-directory: apps/api
        run: |
          # Install dependencies if needed
          if [ ! -d "node_modules" ]; then
            npm ci
          fi
          
          # Get database connection details from CloudFormation stack
          STACK_NAME="my-many-books-infrastructure-${{ needs.setup.outputs.environment }}"
          
          DB_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabaseEndpoint`].OutputValue' \
            --output text)
          
          DB_PORT=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabasePort`].OutputValue' \
            --output text)
          
          if [ -z "$DB_ENDPOINT" ] || [ -z "$DB_PORT" ]; then
            echo "Could not retrieve database connection details from CloudFormation"
            exit 1
          fi
          
          # Set environment variables for database connection
          export NODE_ENV="${{ needs.setup.outputs.environment }}"
          export DB_HOST="$DB_ENDPOINT"
          export DB_PORT="$DB_PORT"
          export DB_NAME="my_many_books"
          export DB_SSL="true"
          
          # Get database credentials from Secrets Manager
          SECRET_ARN=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabaseSecretArn`].OutputValue' \
            --output text)
          
          DB_CREDENTIALS=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_ARN" \
            --query 'SecretString' \
            --output text)
          
          export DB_USER=$(echo "$DB_CREDENTIALS" | jq -r '.username')
          export DB_PASSWORD=$(echo "$DB_CREDENTIALS" | jq -r '.password')
          
          echo "Running database migrations..."
          npm run db:migrate
          
          echo "Running database seeders..."
          npm run db:seed

  deploy-api:
    name: Deploy API
    runs-on: ubuntu-latest
    needs: [setup, pre-deployment-checks, deploy-infrastructure]
    environment: ${{ needs.setup.outputs.environment }}
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.deploy-api == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          check-latest: true

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Dependencies
        run: |
          # Use lockfile if compatible, otherwise regenerate
          if ! npm ci 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install --legacy-peer-deps
          fi

      - name: Build API
        # The working-directory is already set, so a simple npm run build will work.
        working-directory: apps/api
        run: npm run build

      - name: Deploy API with Serverless
        working-directory: apps/api
        run: |
          export NODE_ENV=${{ needs.setup.outputs.environment }}
          export STAGE=${{ needs.setup.outputs.environment }}
          export DB_HOST=${{ secrets.DB_HOST }}
          export DB_PORT=${{ secrets.DB_PORT }}
          export DB_NAME=${{ secrets.DB_NAME }}
          export DB_USER=${{ secrets.DB_USER }}
          export DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          
          # Disable Serverless Framework telemetry and authentication
          export SLS_TELEMETRY_DISABLED=1
          export SLS_INTERACTIVE_SETUP_ENABLE=false
          export SERVERLESS_ACCESS_KEY=""
          
          echo "Deploying API to ${{ needs.setup.outputs.environment }}"
          echo "Using Serverless Framework $(npx serverless --version)"
          npx serverless deploy --stage ${{ needs.setup.outputs.environment }} --verbose

  deploy-web-app:
    name: Deploy Web App
    runs-on: ubuntu-latest
    needs: [setup, pre-deployment-checks]
    environment: ${{ needs.setup.outputs.environment }}
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.deploy-web-app == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          check-latest: true

      - name: Install Dependencies
        run: |
          # Use lockfile if compatible, otherwise regenerate
          if ! npm ci 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install --legacy-peer-deps
          fi

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Cognito Configuration
        id: cognito-config
        run: |
          # Get Cognito resource IDs from deployed API stack
          STACK_NAME="my-many-books-api-${{ needs.setup.outputs.environment }}"
          USER_POOL_ID=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='CognitoUserPoolId'].OutputValue" --output text)
          CLIENT_ID=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='CognitoUserPoolClientId'].OutputValue" --output text)
          IDENTITY_POOL_ID=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='CognitoIdentityPoolId'].OutputValue" --output text)
          API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].Outputs[?OutputKey=='ServiceEndpoint'].OutputValue" --output text)
          
          echo "user-pool-id=$USER_POOL_ID" >> $GITHUB_OUTPUT
          echo "client-id=$CLIENT_ID" >> $GITHUB_OUTPUT
          echo "identity-pool-id=$IDENTITY_POOL_ID" >> $GITHUB_OUTPUT
          echo "api-endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT

      - name: Build Web App
        working-directory: apps/web-app
        run: npm run build
        env:
          NODE_ENV: ${{ needs.setup.outputs.environment == 'prod' && 'production' || 'development' }}
          VITE_COGNITO_USER_POOL_ID: ${{ steps.cognito-config.outputs.user-pool-id }}
          VITE_COGNITO_USER_POOL_CLIENT_ID: ${{ steps.cognito-config.outputs.client-id }}
          VITE_COGNITO_IDENTITY_POOL_ID: ${{ steps.cognito-config.outputs.identity-pool-id }}
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_API_BASE_URL: ${{ steps.cognito-config.outputs.api-endpoint }}

      - name: Deploy to S3
        working-directory: apps/web-app
        run: |
          BUCKET_NAME="my-many-books-web-${{ needs.setup.outputs.environment }}"
          echo "Deploying web app to S3 bucket: $BUCKET_NAME"
          
          # Create bucket if it doesn't exist
          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Creating S3 bucket: $BUCKET_NAME"
            aws s3 mb s3://$BUCKET_NAME
            
            # Disable public access block to allow public website
            echo "Disabling public access block..."
            aws s3api put-public-access-block \
              --bucket "$BUCKET_NAME" \
              --public-access-block-configuration \
              "BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false"
            
            # Wait for public access block to be applied
            sleep 5
            
            # Enable static website hosting
            echo "Enabling static website hosting..."
            aws s3 website s3://$BUCKET_NAME --index-document index.html --error-document index.html
            
            # Set public read policy
            echo "Setting bucket policy..."
            aws s3api put-bucket-policy --bucket "$BUCKET_NAME" --policy "{
              \"Version\": \"2012-10-17\",
              \"Statement\": [
                {
                  \"Sid\": \"PublicReadGetObject\",
                  \"Effect\": \"Allow\",
                  \"Principal\": \"*\",
                  \"Action\": \"s3:GetObject\",
                  \"Resource\": \"arn:aws:s3:::${BUCKET_NAME}/*\"
                }
              ]
            }"
          fi
          
          # Sync build files to S3
          aws s3 sync build/ s3://$BUCKET_NAME --delete
          
          # Invalidate CloudFront cache (optional - skip if no permissions)
          if aws cloudfront list-distributions >/dev/null 2>&1; then
            DISTRIBUTION_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[0].DomainName=='$BUCKET_NAME.s3.amazonaws.com'].Id | [0]" --output text)
            if [ "$DISTRIBUTION_ID" != "None" ] && [ "$DISTRIBUTION_ID" != "" ]; then
              aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"
            fi
          else
            echo "CloudFront permissions not available, skipping cache invalidation"
          fi

  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: [setup, deploy-api, deploy-web-app]
    environment: ${{ needs.setup.outputs.environment }}
    if: always() && needs.setup.outputs.should-deploy == 'true' && (needs.deploy-api.result == 'success' || needs.setup.outputs.deploy-api == 'false')
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          check-latest: true

      - name: Install Newman
        run: npm install -g newman

      - name: Configure Test Environment
        run: |
          # Get the API Gateway URL from Serverless deployment
          if [ "${{ needs.deploy-api.result }}" == "success" ]; then
            case "${{ needs.setup.outputs.environment }}" in
              "dev")
                echo "API_BASE_URL=https://api.my-many-books.com/dev" >> $GITHUB_ENV
                ;;
              "staging")
                echo "API_BASE_URL=https://api.my-many-books.com/staging" >> $GITHUB_ENV
                ;;
              "prod")
                echo "API_BASE_URL=https://api.my-many-books.com/prod" >> $GITHUB_ENV
                ;;
            esac
          else
            echo "API deployment skipped, no API URL available for testing"
            echo "API_BASE_URL=" >> $GITHUB_ENV
          fi

      - name: Run Health Checks
        run: |
          if [ -z "${{ env.API_BASE_URL }}" ]; then
            echo "No API URL configured, skipping health checks"
            exit 0
          fi
          
          echo "Running health checks against ${{ env.API_BASE_URL }}"
          
          for i in {1..30}; do
            if curl -f ${{ env.API_BASE_URL }}/health; then
              echo "Health check passed"
              break
            fi
            echo "Waiting for deployment to be ready... (attempt $i/30)"
            sleep 10
          done
        continue-on-error: true

      - name: Run Smoke Tests
        working-directory: apps/api
        run: |
          if [ -z "${{ env.API_BASE_URL }}" ]; then
            echo "No API URL configured, skipping smoke tests"
            exit 0
          fi
          
          if [ -f "postman/My-Many-Books-API.postman_collection.json" ]; then
            newman run postman/My-Many-Books-API.postman_collection.json \
              --env-var "baseUrl=${{ env.API_BASE_URL }}" \
              --folder "Health Check" \
              --reporters cli,json \
              --reporter-json-export smoke-test-results.json
          else
            echo "No Postman collection found, skipping smoke tests"
          fi
        continue-on-error: true

  notify-completion:
    name: Notify Completion
    runs-on: ubuntu-latest
    needs: [setup, deploy-api, deploy-web-app, post-deployment-tests]
    if: always() && needs.setup.outputs.should-deploy == 'true'
    
    steps:
      - name: Notify Success
        if: (needs.deploy-api.result == 'success' || needs.setup.outputs.deploy-api == 'false') && (needs.deploy-web-app.result == 'success' || needs.setup.outputs.deploy-web-app == 'false')
        run: |
          echo "✅ Monorepo deployment completed successfully"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Deployed projects: ${{ needs.setup.outputs.affected-projects }}"

      - name: Notify Failure
        if: needs.deploy-api.result == 'failure' || needs.deploy-web-app.result == 'failure'
        run: |
          echo "❌ Monorepo deployment failed"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Check the logs for failure details"
          exit 1