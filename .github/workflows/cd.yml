name: Monorepo CD

on:
  push:
    branches: [ main, develop, feature/security-authentication-improvements ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      projects:
        description: 'Projects to deploy (comma-separated: api,web-app)'
        required: true
        default: 'api'
        type: string

env:
  NODE_VERSION: '22.x'
  AWS_REGION: 'us-west-2'
  API_PREFIX: '/api'
  API_ROUTE_VERSION: 'v1'

jobs:
  setup:
    name: Setup Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy: ${{ steps.env.outputs.should-deploy }}
      affected-projects: ${{ steps.affected.outputs.projects }}
      deploy-api: ${{ steps.projects.outputs.deploy-api }}
      deploy-web-app: ${{ steps.projects.outputs.deploy-web-app }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Dependencies
        run: |
          # Generate lockfile with correct Node version if needed
          if ! npm ci --ignore-scripts 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install --ignore-scripts
          fi

      - name: Determine Environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine Affected Projects
        id: affected
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PROJECTS="${{ github.event.inputs.projects }}"
          else
            # Since Nx binary is not available, deploy all projects for develop/main branches
            # This ensures all changes are deployed when pushing to main branches
            PROJECTS="api,web-app"
          fi
          echo "projects=$PROJECTS" >> $GITHUB_OUTPUT
          echo "Affected projects: $PROJECTS"

      - name: Determine Projects to Deploy
        id: projects
        run: |
          PROJECTS="${{ steps.affected.outputs.projects }}"
          
          if [[ "$PROJECTS" == *"api"* ]]; then
            echo "deploy-api=true" >> $GITHUB_OUTPUT
          else
            echo "deploy-api=false" >> $GITHUB_OUTPUT
          fi
          
          if [[ "$PROJECTS" == *"web-app"* ]]; then
            echo "deploy-web-app=true" >> $GITHUB_OUTPUT
          else
            echo "deploy-web-app=false" >> $GITHUB_OUTPUT
          fi

  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    needs: [setup]
    if: needs.setup.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Dependencies
        run: |
          # Use lockfile if compatible, otherwise regenerate  
          if ! npm ci --ignore-scripts 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install --legacy-peer-deps --ignore-scripts
          fi

      - name: Build Projects to be Deployed
        # Install dependencies and build each project individually to avoid native binary issues
        run: |
          BUILD_PROJECTS="${{ needs.setup.outputs.affected-projects }}"
          if [ -n "$BUILD_PROJECTS" ]; then
            IFS=',' read -ra ADDR <<< "$BUILD_PROJECTS"
            for project in "${ADDR[@]}"; do
              if [ "$project" == "api" ]; then
                echo "Building project: $project"
                cd apps/api
                # Install dependencies individually for this project
                if ! npm ci --ignore-scripts 2>/dev/null; then
                  echo "Lockfile incompatible for $project, regenerating..."
                  rm -f package-lock.json
                  npm install --legacy-peer-deps --ignore-scripts
                fi
                npm run build
                cd ../..
              elif [ "$project" == "web-app" ]; then
                echo "Building project: $project"
                cd apps/web-app
                echo "=== Starting web-app dependency installation for build ==="
                if ! timeout 300 npm ci --ignore-scripts 2>/dev/null; then
                  echo "npm ci failed or timed out, trying fallback installation..."
                  rm -f package-lock.json
                  echo "Installing dependencies with --legacy-peer-deps --ignore-scripts and timeout..."
                  timeout 600 npm install --legacy-peer-deps --ignore-scripts || {
                    echo "ERROR: npm install timed out after 10 minutes"
                    exit 1
                  }
                fi
                echo "=== Rebuilding native dependencies for build ==="
                timeout 300 npm rebuild || {
                  echo "WARNING: npm rebuild timed out after 5 minutes, continuing..."
                }
                echo "=== Installing Rollup native binary specifically for build ==="
                timeout 180 npm install @rollup/rollup-linux-x64-gnu --no-save || {
                  echo "WARNING: Could not install Rollup native binary, continuing..."
                }
                echo "=== Starting web-app build ==="
                npm run build
                cd ../..
              else
                echo "Skipping non-deployable project: $project"
              fi
            done
          else
            echo "No projects to build for deployment."
          fi

      - name: Run Security Checks
        run: |
          npm audit --audit-level=high
          npx audit-ci --high
        continue-on-error: true

      - name: Validate Environment Configuration
        run: |
          echo "Validating configuration for ${{ needs.setup.outputs.environment }} environment"

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [setup, pre-deployment-checks]
    environment: ${{ needs.setup.outputs.environment }}
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.deploy-api == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Infrastructure Stack
        run: |
          STACK_NAME="my-many-books-infrastructure-${{ needs.setup.outputs.environment }}"
          TEMPLATE_FILE="apps/api/deployment/cloudformation/infrastructure.yml"
          
          # Set parameters based on environment
          PARAMETERS="ParameterKey=Environment,ParameterValue=${{ needs.setup.outputs.environment }}"
          
          case "${{ needs.setup.outputs.environment }}" in
            "prod")
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseInstanceClass,ParameterValue=db.t3.small"
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseAllocatedStorage,ParameterValue=50"
              PARAMETERS="$PARAMETERS ParameterKey=EnableMultiAZ,ParameterValue=true"
              ;;
            "staging")
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseInstanceClass,ParameterValue=db.t3.micro"
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseAllocatedStorage,ParameterValue=20"
              PARAMETERS="$PARAMETERS ParameterKey=EnableMultiAZ,ParameterValue=false"
              ;;
            "dev")
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseInstanceClass,ParameterValue=db.t3.micro"
              PARAMETERS="$PARAMETERS ParameterKey=DatabaseAllocatedStorage,ParameterValue=20"
              PARAMETERS="$PARAMETERS ParameterKey=EnableMultiAZ,ParameterValue=false"
              ;;
          esac
          
          # Check if stack exists and get its status
          if aws cloudformation describe-stacks --stack-name "$STACK_NAME" >/dev/null 2>&1; then
            STACK_STATUS=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query 'Stacks[0].StackStatus' \
              --output text)

            echo "Stack exists with status: $STACK_STATUS"

            # Handle ROLLBACK_IN_PROGRESS or UPDATE_ROLLBACK_IN_PROGRESS - wait for it to complete
            if [ "$STACK_STATUS" = "ROLLBACK_IN_PROGRESS" ] || [ "$STACK_STATUS" = "UPDATE_ROLLBACK_IN_PROGRESS" ]; then
              echo "Stack is in $STACK_STATUS state, waiting for rollback to complete..."
              aws cloudformation wait stack-rollback-complete --stack-name "$STACK_NAME" 2>/dev/null || \
              aws cloudformation wait stack-update-rollback-complete --stack-name "$STACK_NAME" 2>/dev/null || true

              # Get the new status after rollback completes
              STACK_STATUS=$(aws cloudformation describe-stacks \
                --stack-name "$STACK_NAME" \
                --query 'Stacks[0].StackStatus' \
                --output text)
              echo "Rollback completed, stack is now in $STACK_STATUS state"
            fi

            # If stack is in ROLLBACK_COMPLETE or UPDATE_ROLLBACK_COMPLETE state, it must be deleted first
            if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ] || [ "$STACK_STATUS" = "UPDATE_ROLLBACK_COMPLETE" ]; then
              echo "Stack is in $STACK_STATUS state, deleting it first..."
              aws cloudformation delete-stack --stack-name "$STACK_NAME"
              echo "Waiting for stack deletion to complete (this may take several minutes)..."

              # Custom wait loop with longer timeout (20 minutes max)
              MAX_WAIT_TIME=1200  # 20 minutes in seconds
              WAIT_INTERVAL=30     # Check every 30 seconds
              ELAPSED_TIME=0

              while [ $ELAPSED_TIME -lt $MAX_WAIT_TIME ]; do
                STACK_STATUS=$(aws cloudformation describe-stacks \
                  --stack-name "$STACK_NAME" \
                  --query 'Stacks[0].StackStatus' \
                  --output text 2>&1 || echo "DELETED")

                if [ "$STACK_STATUS" = "DELETED" ] || echo "$STACK_STATUS" | grep -q "does not exist"; then
                  echo "Stack successfully deleted"
                  break
                fi

                echo "Stack status: $STACK_STATUS (waited ${ELAPSED_TIME}s / ${MAX_WAIT_TIME}s)"
                sleep $WAIT_INTERVAL
                ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
              done

              if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
                echo "Stack deletion timeout after ${MAX_WAIT_TIME}s. Current status: $STACK_STATUS"
                exit 1
              fi

              echo "Creating new infrastructure stack: $STACK_NAME"
              aws cloudformation create-stack \
                --stack-name "$STACK_NAME" \
                --template-body "file://$TEMPLATE_FILE" \
                --parameters $PARAMETERS \
                --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM

              echo "Waiting for stack creation to complete..."
              # Wait with error handling to display stack events on failure
              if ! aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" 2>&1; then
                echo "Stack creation failed. Retrieving stack events..."
                aws cloudformation describe-stack-events \
                  --stack-name "$STACK_NAME" \
                  --query 'StackEvents[?ResourceStatus==`CREATE_FAILED` || ResourceStatus==`ROLLBACK_IN_PROGRESS` || ResourceStatus==`ROLLBACK_COMPLETE`].[LogicalResourceId,ResourceStatus,ResourceStatusReason]' \
                  --output table
                echo "Full stack status:"
                aws cloudformation describe-stacks \
                  --stack-name "$STACK_NAME" \
                  --query 'Stacks[0].[StackStatus,StackStatusReason]' \
                  --output table
                exit 1
              fi
            else
              echo "Updating existing infrastructure stack: $STACK_NAME"

              # Capture output and check for "No updates" message
              UPDATE_OUTPUT=$(aws cloudformation update-stack \
                --stack-name "$STACK_NAME" \
                --template-body "file://$TEMPLATE_FILE" \
                --parameters $PARAMETERS \
                --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM 2>&1) || {
                  exit_code=$?
                  if echo "$UPDATE_OUTPUT" | grep -q "No updates are to be performed"; then
                    echo "No updates needed - infrastructure stack is already up-to-date"
                    exit 0
                  else
                    echo "Failed to update infrastructure stack"
                    echo "$UPDATE_OUTPUT"
                    exit $exit_code
                  fi
                }

              echo "Stack update initiated successfully"
              echo "Waiting for stack update to complete..."
              aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"
            fi
          else
            echo "Creating new infrastructure stack: $STACK_NAME"
            aws cloudformation create-stack \
              --stack-name "$STACK_NAME" \
              --template-body "file://$TEMPLATE_FILE" \
              --parameters $PARAMETERS \
              --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM

            echo "Waiting for stack creation to complete..."
            # Wait with error handling to display stack events on failure
            if ! aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" 2>&1; then
              echo "Stack creation failed. Retrieving stack events..."
              aws cloudformation describe-stack-events \
                --stack-name "$STACK_NAME" \
                --query 'StackEvents[?ResourceStatus==`CREATE_FAILED` || ResourceStatus==`ROLLBACK_IN_PROGRESS` || ResourceStatus==`ROLLBACK_COMPLETE`].[LogicalResourceId,ResourceStatus,ResourceStatusReason]' \
                --output table
              echo "Full stack status:"
              aws cloudformation describe-stacks \
                --stack-name "$STACK_NAME" \
                --query 'Stacks[0].[StackStatus,StackStatusReason]' \
                --output table
              exit 1
            fi
          fi
          
          echo "Infrastructure deployment completed successfully"

      - name: Run Database Migrations
        run: |
          # Install all workspace dependencies from root (includes all workspace packages)
          echo "Installing workspace dependencies..."
          npm ci

          # Get database connection details from CloudFormation stack
          STACK_NAME="my-many-books-infrastructure-${{ needs.setup.outputs.environment }}"

          DB_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabaseEndpoint`].OutputValue' \
            --output text)

          DB_PORT=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabasePort`].OutputValue' \
            --output text)

          if [ -z "$DB_ENDPOINT" ] || [ -z "$DB_PORT" ]; then
            echo "Could not retrieve database connection details from CloudFormation"
            exit 1
          fi

          # Get database credentials from Secrets Manager
          SECRET_ARN=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabaseSecretArn`].OutputValue' \
            --output text)

          DB_CREDENTIALS=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_ARN" \
            --query 'SecretString' \
            --output text)

          DB_USER=$(echo "$DB_CREDENTIALS" | jq -r '.username')
          DB_PASSWORD=$(echo "$DB_CREDENTIALS" | jq -r '.password')

          echo "Running database migrations..."
          NODE_ENV="${{ needs.setup.outputs.environment }}" \
          DB_HOST="$DB_ENDPOINT" \
          DB_PORT="$DB_PORT" \
          DB_NAME="my_many_books" \
          DB_USER="$DB_USER" \
          DB_PASSWORD="$DB_PASSWORD" \
          DB_SSL="true" \
          npm run -w my-many-books-api db:migrate

          echo "Running database seeders..."
          NODE_ENV="${{ needs.setup.outputs.environment }}" \
          DB_HOST="$DB_ENDPOINT" \
          DB_PORT="$DB_PORT" \
          DB_NAME="my_many_books" \
          DB_USER="$DB_USER" \
          DB_PASSWORD="$DB_PASSWORD" \
          DB_SSL="true" \
          npm run -w my-many-books-api db:seed

  deploy-api:
    name: Deploy API
    runs-on: ubuntu-latest
    needs: [setup, pre-deployment-checks, deploy-infrastructure]
    environment: ${{ needs.setup.outputs.environment }}
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.deploy-api == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Dependencies
        run: |
          # Use lockfile if compatible, otherwise regenerate  
          if ! npm ci --ignore-scripts 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install --legacy-peer-deps --ignore-scripts
          fi

      - name: Build API
        # The working-directory is already set, so a simple npm run build will work.
        working-directory: apps/api
        run: npm run build

      - name: Get Database Credentials
        id: db-credentials
        run: |
          STACK_NAME="my-many-books-infrastructure-${{ needs.setup.outputs.environment }}"
          SECRET_ARN=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`DatabaseSecretArn`].OutputValue' \
            --output text)

          DB_CREDENTIALS=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_ARN" \
            --query 'SecretString' \
            --output text)

          DB_PASSWORD=$(echo "$DB_CREDENTIALS" | jq -r '.password')
          echo "db-password=$DB_PASSWORD" >> $GITHUB_OUTPUT
          echo "Database credentials retrieved from Secrets Manager"

      - name: Deploy API with Serverless
        working-directory: apps/api
        run: |
          export NODE_ENV=${{ needs.setup.outputs.environment }}
          export STAGE=${{ needs.setup.outputs.environment }}
          export DB_PASSWORD="${{ steps.db-credentials.outputs.db-password }}"

          # Serverless Framework authentication
          export SERVERLESS_ACCESS_KEY=${{ secrets.SERVERLESS_ACCESS_KEY }}

          echo "Deploying API to ${{ needs.setup.outputs.environment }}"
          echo "Using Serverless Framework $(npx serverless --version)"
          npx serverless deploy --stage ${{ needs.setup.outputs.environment }} --verbose

  deploy-web-app:
    name: Deploy Web App
    runs-on: ubuntu-latest
    needs: [setup, pre-deployment-checks, deploy-api]
    environment: ${{ needs.setup.outputs.environment }}
    if: needs.setup.outputs.should-deploy == 'true' && needs.setup.outputs.deploy-web-app == 'true' && always() && (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped' || needs.deploy-api.result == 'failure')
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Dependencies
        run: |
          # Use lockfile if compatible, otherwise regenerate  
          if ! npm ci --ignore-scripts 2>/dev/null; then
            echo "Lockfile incompatible, regenerating..."
            rm -f package-lock.json
            npm install --legacy-peer-deps --ignore-scripts
          fi

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Cognito Configuration
        id: cognito-config
        run: |
          # Get Cognito resource IDs and API endpoint from API stack (Cognito is part of Serverless deployment)
          API_STACK="my-many-books-api-${{ needs.setup.outputs.environment }}"
          USER_POOL_ID=$(aws cloudformation describe-stacks --stack-name $API_STACK --query "Stacks[0].Outputs[?OutputKey=='CognitoUserPoolId'].OutputValue" --output text)
          CLIENT_ID=$(aws cloudformation describe-stacks --stack-name $API_STACK --query "Stacks[0].Outputs[?OutputKey=='CognitoUserPoolClientId'].OutputValue" --output text)
          IDENTITY_POOL_ID=$(aws cloudformation describe-stacks --stack-name $API_STACK --query "Stacks[0].Outputs[?OutputKey=='CognitoIdentityPoolId'].OutputValue" --output text)
          API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name $API_STACK --query "Stacks[0].Outputs[?OutputKey=='ServiceEndpoint'].OutputValue" --output text)

          echo "user-pool-id=$USER_POOL_ID" >> $GITHUB_OUTPUT
          echo "client-id=$CLIENT_ID" >> $GITHUB_OUTPUT
          echo "identity-pool-id=$IDENTITY_POOL_ID" >> $GITHUB_OUTPUT
          echo "api-endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT

      - name: Build Web App
        working-directory: apps/web-app
        run: |
          echo "=== Installing web-app dependencies for build ==="
          if ! timeout 300 npm ci --ignore-scripts 2>/dev/null; then
            echo "npm ci failed or timed out, trying fallback installation..."
            rm -f package-lock.json
            timeout 600 npm install --legacy-peer-deps --ignore-scripts || {
              echo "ERROR: npm install timed out after 10 minutes"
              exit 1
            }
          fi
          echo "=== Rebuilding native dependencies ==="
          timeout 300 npm rebuild || {
            echo "WARNING: npm rebuild timed out, continuing..."
          }
          echo "=== Installing Rollup native binary ==="
          timeout 180 npm install @rollup/rollup-linux-x64-gnu --no-save || {
            echo "WARNING: Could not install Rollup native binary, continuing..."
          }
          echo "=== Building web-app ==="
          npm run build
        env:
          NODE_ENV: ${{ needs.setup.outputs.environment == 'prod' && 'production' || 'development' }}
          VITE_COGNITO_USER_POOL_ID: ${{ steps.cognito-config.outputs.user-pool-id }}
          VITE_COGNITO_USER_POOL_CLIENT_ID: ${{ steps.cognito-config.outputs.client-id }}
          VITE_COGNITO_IDENTITY_POOL_ID: ${{ steps.cognito-config.outputs.identity-pool-id }}
          VITE_AWS_REGION: ${{ env.AWS_REGION }}
          VITE_API_BASE_URL: ${{ steps.cognito-config.outputs.api-endpoint }}${{ env.API_PREFIX }}/${{ env.API_ROUTE_VERSION }}

      - name: Deploy to S3
        working-directory: apps/web-app
        run: |
          BUCKET_NAME="my-many-books-web-${{ needs.setup.outputs.environment }}"
          echo "Deploying web app to S3 bucket: $BUCKET_NAME"
          
          # Create bucket if it doesn't exist
          if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Creating S3 bucket: $BUCKET_NAME"
            aws s3 mb s3://$BUCKET_NAME
            
            # Disable public access block to allow public website
            echo "Disabling public access block..."
            aws s3api put-public-access-block \
              --bucket "$BUCKET_NAME" \
              --public-access-block-configuration \
              "BlockPublicAcls=false,IgnorePublicAcls=false,BlockPublicPolicy=false,RestrictPublicBuckets=false"
            
            # Wait for public access block to be applied
            sleep 5
            
            # Enable static website hosting
            echo "Enabling static website hosting..."
            aws s3 website s3://$BUCKET_NAME --index-document index.html --error-document index.html
            
            # Set public read policy
            echo "Setting bucket policy..."
            aws s3api put-bucket-policy --bucket "$BUCKET_NAME" --policy "{
              \"Version\": \"2012-10-17\",
              \"Statement\": [
                {
                  \"Sid\": \"PublicReadGetObject\",
                  \"Effect\": \"Allow\",
                  \"Principal\": \"*\",
                  \"Action\": \"s3:GetObject\",
                  \"Resource\": \"arn:aws:s3:::${BUCKET_NAME}/*\"
                }
              ]
            }"
          fi
          
          # Sync build files to S3
          aws s3 sync build/ s3://$BUCKET_NAME --delete
          
          # Invalidate CloudFront cache (optional - skip if no permissions)
          if aws cloudfront list-distributions >/dev/null 2>&1; then
            DISTRIBUTION_ID=$(aws cloudfront list-distributions --query "DistributionList.Items[?Origins.Items[0].DomainName=='$BUCKET_NAME.s3.amazonaws.com'].Id | [0]" --output text)
            if [ "$DISTRIBUTION_ID" != "None" ] && [ "$DISTRIBUTION_ID" != "" ]; then
              aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"
            fi
          else
            echo "CloudFront permissions not available, skipping cache invalidation"
          fi

  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: [setup, deploy-api, deploy-web-app]
    environment: ${{ needs.setup.outputs.environment }}
    if: always() && needs.setup.outputs.should-deploy == 'true' && (needs.deploy-api.result == 'success' || needs.setup.outputs.deploy-api == 'false')
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Newman
        run: npm install -g newman

      - name: Configure Test Environment
        run: |
          # Get the API Gateway URL from Serverless deployment
          if [ "${{ needs.deploy-api.result }}" == "success" ]; then
            case "${{ needs.setup.outputs.environment }}" in
              "dev")
                echo "API_BASE_URL=https://api.my-many-books.com/dev" >> $GITHUB_ENV
                ;;
              "staging")
                echo "API_BASE_URL=https://api.my-many-books.com/staging" >> $GITHUB_ENV
                ;;
              "prod")
                echo "API_BASE_URL=https://api.my-many-books.com/prod" >> $GITHUB_ENV
                ;;
            esac
          else
            echo "API deployment skipped, no API URL available for testing"
            echo "API_BASE_URL=" >> $GITHUB_ENV
          fi

      - name: Run Health Checks
        run: |
          if [ -z "${{ env.API_BASE_URL }}" ]; then
            echo "No API URL configured, skipping health checks"
            exit 0
          fi
          
          echo "Running health checks against ${{ env.API_BASE_URL }}"
          
          for i in {1..30}; do
            if curl -f ${{ env.API_BASE_URL }}/health; then
              echo "Health check passed"
              break
            fi
            echo "Waiting for deployment to be ready... (attempt $i/30)"
            sleep 10
          done
        continue-on-error: true

      - name: Run Smoke Tests
        working-directory: apps/api
        run: |
          if [ -z "${{ env.API_BASE_URL }}" ]; then
            echo "No API URL configured, skipping smoke tests"
            exit 0
          fi
          
          if [ -f "postman/My-Many-Books-API.postman_collection.json" ]; then
            newman run postman/My-Many-Books-API.postman_collection.json \
              --env-var "baseUrl=${{ env.API_BASE_URL }}" \
              --folder "Health Check" \
              --reporters cli,json \
              --reporter-json-export smoke-test-results.json
          else
            echo "No Postman collection found, skipping smoke tests"
          fi
        continue-on-error: true

  notify-completion:
    name: Notify Completion
    runs-on: ubuntu-latest
    needs: [setup, deploy-api, deploy-web-app, post-deployment-tests]
    if: always() && needs.setup.outputs.should-deploy == 'true'
    
    steps:
      - name: Notify Success
        if: (needs.deploy-api.result == 'success' || needs.setup.outputs.deploy-api == 'false') && (needs.deploy-web-app.result == 'success' || needs.setup.outputs.deploy-web-app == 'false')
        run: |
          echo "✅ Monorepo deployment completed successfully"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Deployed projects: ${{ needs.setup.outputs.affected-projects }}"

      - name: Notify Failure
        if: needs.deploy-api.result == 'failure' || needs.deploy-web-app.result == 'failure'
        run: |
          echo "❌ Monorepo deployment failed"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          echo "Check the logs for failure details"
          exit 1